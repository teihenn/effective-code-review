# コーディングのtips

- [コーディングのtips](#コーディングのtips)
  - [良い変更説明を書く](#良い変更説明を書く)
    - [コミットメッセージをちゃんと書く](#コミットメッセージをちゃんと書く)
      - [Gitのコミットメッセージの標準: 50/72ルール\[2\]\[3\]](#gitのコミットメッセージの標準-5072ルール23)
    - [コードにコメントを書く](#コードにコメントを書く)
  - [コードを小さく保つ](#コードを小さく保つ)
  - [コードは債務である認識を忘れない\[1\]](#コードは債務である認識を忘れない1)
  - [コミットメッセージにprefixを付ける\[6\]](#コミットメッセージにprefixを付ける6)
  - [コミット単位に注意を払う](#コミット単位に注意を払う)
  - [merge先のブランチの変更を反映するのに、mergeではなくrebaseを検討する\[4\]](#merge先のブランチの変更を反映するのにmergeではなくrebaseを検討する4)
  - [ドラフトPRを上手く使う](#ドラフトprを上手く使う)


## 良い変更説明を書く

### コミットメッセージをちゃんと書く

- コミットメッセージはレビュアーや将来の自分などのためにもきちんと書く
- 修正の理由や背景など、コード差分に現れないことが書かれているとレビューがしやすい
- よくあるNG例
    - 「レビュー指摘対応」
        - どのコメントに対するものかわからないのでレビュアーとしてはこのコミットメッセージはつらい
    - 「バグ修正」
        - *これだけではレビュアーや将来のコード考古学者にとっては助けにならない*[1]

#### Gitのコミットメッセージの標準: 50/72ルール[2][3]

- 50/72ルールとは
    - サマリーを現在形で50文字以内で書く(日本語なら25文字くらい)
    - それ以上のテキストを書く場合は、2行目を空行にする
    - 好きなだけテキストを追加してよいが、幅が72文字以内になるようにフォーマットする
- 50/72ルールの利点
    - git log --onelineやGitHub, Bitbucketなど各ツールでコミットの一覧を見るときに見やすい
    - 現在形で書くことで行が短くなる
- コミットメッセージの内容
    - コードが自明なときはサマリーだけで良い
        - 少しでも疑問があるときは、コンテキストを追加する
    - コミットの差分には何をどのように変更したのかの情報がすでに含まれているので、コミットメッセージではそれよりもなぜその変更をしたのか、なぜその形になっているのかを説明するのに最適

例
```
TimeOfDayのstructを導入

これによってMaitreDのコンストラクターパラメーターの役割が明確になる。
TimeOfDay型の大部分はVisualStudioが生成した。
```

### コードにコメントを書く

- *変更内で自分がやったことの理由をレビュアーが理解できないなら、自分がやったことがたとえ正しいとしても、そのようなコードの構造かコメント（またはその両方）は改善が必要だということがはっきりと表されている。コードレビュープロセスの最中に新しい決定が行われるに至った場合、変更履歴を更新するか、実装内に適切なコメントを追加しなければならない。コードレビューは、現在自分が行う活動であるだけでなく、自分の行ったことを後世に向けて記録するために行う活動なのだ。*[1]

## コードを小さく保つ

- サイクロマティック複雑度などの話

## コードは債務である認識を忘れない[1]

## コミットメッセージにprefixを付ける[6]

- 何の変更なのかレビュアーがわかりやすい
- 開発者が機能をprefixごとに作るようになる
- （prefixを正しく付けることは本質ではなく、commitの単位を意識したり見やすくする意識付けに効果がある）

Angularプロジェクトで使用されているprefix(https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#type)
```
feat: A new feature
fix: A bug fix
docs: Documentation only changes
style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
refactor: A code change that neither fixes a bug nor adds a feature
perf: A code change that improves performance
test: Adding missing or correcting existing tests
chore: Changes to the build process or auxiliary tools and libraries such as documentation generation
```

- choreは、上記に当てはまらないものにも使う
- prefixはあくまでコミットが何をいじったものなのかわかりやすくするためなので分類は考えすぎず大雑把で良い

## コミット単位に注意を払う

- コミット単位は意味のあるまとまりになるようにする
    - そうなっていればコミットメッセージも書きやすくprefixも上手く付けられるはず
- コミットは必要に応じてrebaseでまとめたり、git commit --amendを活用する
- コミットメッセージに合致しない差分を混ぜない

## merge先のブランチの変更を反映するのに、mergeではなくrebaseを検討する[4]

- rebaseの場合は不要なマージコミットが作成されない
- featureブランチへのマージコミットはノイズになり本来の修正の履歴が分かりづらくなってしまう
    - bitbucketなどのGUIではさほど見づらくないが、git logで見るとマージコミットの中身のそれぞれのコミットのログも表示されてしまうのでかなり見づらくなる。
    - rebaseしておいたほうがコミットツリーが直線的になりわかりやすい
- rebaseは履歴を書き換えるため、他の開発者と共有しているブランチに対してはmergeを使用するほうが良い
- PR提出後はmergeのほうが好ましい
    - PR提出後は、他の開発者がレビューやテストを行っている可能性があるので、履歴を変更しないほうが安全である
    - rebaseするとコミットハッシュが変わるので、特定のコミットを参照して話をしている場合などに、指しているコミットが変わってしまうかもしれない
    - 要は他の人がpullしている可能性などがある場合はrebaseはやめておいたほうが良い
- 有名OSSでもmerge先ブランチの反映にはrebaseを使うことをルールにしているものも多い

## ドラフトPRを上手く使う

- 大きな手戻りを防ぐため、途中でもチームメンバーと相談したいことがあればドラフトPRを出し相談する
- BitbucketではドラフトPR機能は無いけど、レビュアーの設定を無しにすれば似たような使い方は出来そう
    - （ただしPRのリードタイムを計測している場合、レビュー時間でないものが含まれるようになるので、そこは回避策があったほうが良いのかもしれない）
