# コーディングのtips

- [コーディングのtips](#コーディングのtips)
  - [コードを小さく保つため、適切に抽象化する\[2\]](#コードを小さく保つため適切に抽象化する2)
  - [良い変更説明を書く](#良い変更説明を書く)
    - [コミットメッセージをちゃんと書く](#コミットメッセージをちゃんと書く)
      - [Gitのコミットメッセージの標準: 50/72ルール\[2\]\[3\]](#gitのコミットメッセージの標準-5072ルール23)
    - [コードにコメントを書く](#コードにコメントを書く)
  - [コマンドクエリ分離（CQS）\[2\]](#コマンドクエリ分離cqs2)
  - [コミットメッセージにprefixを付ける\[7\]](#コミットメッセージにprefixを付ける7)
  - [コミット単位に注意を払う](#コミット単位に注意を払う)
  - [コードは債務である認識を忘れない\[1\]](#コードは債務である認識を忘れない1)
  - [merge先のブランチの変更を反映するのに、mergeではなくrebaseを検討する\[4\]](#merge先のブランチの変更を反映するのにmergeではなくrebaseを検討する4)
  - [ドラフトPRを上手く使う](#ドラフトprを上手く使う)


## コードを小さく保つため、適切に抽象化する[2]

- サイクロマティック複雑度
	- コードの複雑度のメトリクス。コードの断片を通る経路を数えるもの
	- 1から始めてifやforなどが何回登場するかを数える
		- ポイントは分岐とループの命令を数えること
	- キーワードが登場するごとに、（1から始まる）数字をインクリメントする
	- 7を超える場合はその関数は複雑過ぎるためリファクタリングしたほうが良い
		- 人間の短期記憶は4〜7個の情報しか保持できない[10][11]
- 80/24ルール
	- 脳に収まるようにコードを書くため、横幅の最大文字数/メソッドの最大行数の目安を持つと良い
	- 横幅：80文字
	- メソッドの最大行数：24行
	- 横幅を長くしすぎないことで、画面分割してunit testとテスト対象のコードを両方見ることも出来るし、side by sideビューでdiffを見ることも出来る。また縦にも長くしすぎないことで、スクロールせずにメソッドの全容が見える
- どうやって適切に抽象化するのか
	- 物事の本質を抽出する：多くのことを1つのことに置き換える
    - ひとまとまりの処理を1つのメソッドに抽出する
        - 実装の詳細を見ずともその1つのメソッドの意図が分かるようになっていれば、上手く抽象化出来ている

## 良い変更説明を書く

### コミットメッセージをちゃんと書く

- コミットメッセージはレビュアーや将来の自分などのためにもきちんと書く
- 修正の理由や背景など、コード差分に現れないことが書かれているとレビューがしやすい
- よくあるNG例
    - 「レビュー指摘対応」
        - どのコメントに対するものかわからないのでレビュアーとしてはこのコミットメッセージはつらい
    - 「バグ修正」
        - *これだけではレビュアーや将来のコード考古学者にとっては助けにならない*[1]

#### Gitのコミットメッセージの標準: 50/72ルール[2][3]

- 50/72ルールとは
    - サマリーを現在形で50文字以内で書く(日本語なら25文字くらい)
    - それ以上のテキストを書く場合は、2行目を空行にする
    - 好きなだけテキストを追加してよいが、幅が72文字以内になるようにフォーマットする
- 50/72ルールの利点
    - git log --onelineやGitHub, Bitbucketなど各ツールでコミットの一覧を見るときに見やすい
    - 現在形で書くことで行が短くなる
- コミットメッセージの内容
    - コードが自明なときはサマリーだけで良い
        - 少しでも疑問があるときは、コンテキストを追加する
    - コミットの差分には何をどのように変更したのかの情報がすでに含まれているので、コミットメッセージではそれよりもなぜその変更をしたのか、なぜその形になっているのかを説明するのに最適

例
```
TimeOfDayのstructを導入

これによってMaitreDのコンストラクターパラメーターの役割が明確になる。
TimeOfDay型の大部分はVisualStudioが生成した。
```

### コードにコメントを書く

- *変更内で自分がやったことの理由をレビュアーが理解できないなら、自分がやったことがたとえ正しいとしても、そのようなコードの構造かコメント（またはその両方）は改善が必要だということがはっきりと表されている。コードレビュープロセスの最中に新しい決定が行われるに至った場合、変更履歴を更新するか、実装内に適切なコメントを追加しなければならない。コードレビューは、現在自分が行う活動であるだけでなく、自分の行ったことを後世に向けて記録するために行う活動なのだ。*[1]

## コマンドクエリ分離（CQS）[2]

- コマンド：副作用のあるメソッド
	- 副作用：ある手続きが何かの状態を変えること
	- 副作用のあるメソッドはデータを返さないように実装すべきで、つまり戻り値の型はvoidであるべき
        - データを返さないメソッドがあったら、副作用があることがメソッドの存在理由であることがわかる
- クエリ：副作用が無くデータを返すメソッド
	- CQSに従っている場合、あるメソッドに戻り値の型があれば、副作用が無いと理解出来る
- コマンドとクエリを分離したほうが、APIの意図を理解しやすくなる。そして、実装コードを読まなくても、2種類の機能を区別できるようになる
- コマンドよりもクエリのほうが理解しやすいので、コマンドよりもクエリを優先する

## コミットメッセージにprefixを付ける[7]

- 何の変更なのかレビュアーがわかりやすい
- 開発者が機能をprefixごとに作るようになる
- （prefixを正しく付けることは本質ではなく、commitの単位を意識したり見やすくする意識付けに効果がある）

Angularプロジェクトで使用されているprefix(https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#type)
```
feat: A new feature
fix: A bug fix
docs: Documentation only changes
style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
refactor: A code change that neither fixes a bug nor adds a feature
perf: A code change that improves performance
test: Adding missing or correcting existing tests
chore: Changes to the build process or auxiliary tools and libraries such as documentation generation
```

- choreは、上記に当てはまらないものにも使う
- prefixはあくまでコミットが何をいじったものなのかわかりやすくするためなので分類は考えすぎず大雑把で良い

## コミット単位に注意を払う

- コミット単位は意味のあるまとまりになるようにする
    - そうなっていればコミットメッセージも書きやすくprefixも上手く付けられるはず
- コミットは必要に応じてrebaseでまとめたり、git commit --amendを活用する
- コミットメッセージに合致しない差分を混ぜない

## コードは債務である認識を忘れない[1]

- *コードは必要な債務かもしれないが、それ自体では、どこかの誰かにとっての将来の単なる保守タスクである。飛行機が積載する燃料によく似て重量があり、しかし当然ながらその飛行機が飛ぶのに必要だ[1]*
    - そもそも新機能について開発に足る正当な理由があるかや、コードの重複、車輪の再発明等に注意する
- コード行数が多ければ多いほど、コードベースは悪化する[2]
	- コードを増やせば増やすほど、人が読んで理解しなければいけない量が増える

## merge先のブランチの変更を反映するのに、mergeではなくrebaseを検討する[4]

- rebaseの場合は不要なマージコミットが作成されない
- featureブランチへのマージコミットはノイズになり本来の修正の履歴が分かりづらくなってしまう
    - bitbucketなどのGUIではさほど見づらくないが、git logで見るとマージコミットの中身のそれぞれのコミットのログも表示されてしまうのでかなり見づらくなる。
    - rebaseしておいたほうがコミットツリーが直線的になりわかりやすい
- rebaseは履歴を書き換えるため、他の開発者と共有しているブランチに対してはmergeを使用するほうが良い
- PR提出後はmergeのほうが好ましい
    - PR提出後は、他の開発者がレビューやテストを行っている可能性があるので、履歴を変更しないほうが安全である
    - rebaseするとコミットハッシュが変わるので、特定のコミットを参照して話をしている場合などに、指しているコミットが変わってしまうかもしれない
    - 要は他の人がpullしている可能性などがある場合はrebaseはやめておいたほうが良い
- 有名OSSでもmerge先ブランチの反映にはrebaseを使うことをルールにしているものも多い

## ドラフトPRを上手く使う

- 大きな手戻りを防ぐため、途中でもチームメンバーと相談したいことがあればドラフトPRを出し相談する
- BitbucketではドラフトPR機能は無いけど、レビュアーの設定を無しにすれば似たような使い方は出来そう
    - （ただしPRのリードタイムを計測している場合、レビュー時間でないものが含まれるようになるので、そこは回避策があったほうが良いのかもしれない）
